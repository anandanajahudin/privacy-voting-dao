// SPDX‑License‑Identifier: Public Domain
pragma solidity ^0.8.24;

import "./Verifier.sol"; // <‑‑ swap with real verifier once you have a circuit
/**
 * @title PrivacyVotingDAO – minimal DAO with anonymous voting
 * @dev Uses a Semaphore‑style nullifier to stop double‑votes. The verifier
 * here is a stub that *always* returns true – replace it with a real
 * zk‑SNARK verifier for production.
 */
contract PrivacyVotingDAO is Verifier {
    enum ProposalType {
        Binary,
        Multiple
    }
    struct Proposal {
        string title; // human‑readable title
        string description; // off‑chain markdown / IPFS hash
        ProposalType pType; // Binary or Multiple
        string[] options; // ["Yes", "No"] or arbitrary choices
        mapping(uint => uint) tally; // optionIndex ⇒ votes
        mapping(bytes32 => bool) nullifiers; // to prevent double‑votes
        bool open; // voting status
        uint created;
    }
    uint public proposalCount;
    mapping(uint => Proposal) public proposals;
    /** EVENTS */
    event ProposalCreated(uint indexed id, string title, ProposalType pType);
    event VoteCast(uint indexed proposalId, uint optionIdx, bytes32 nullifier);
    event ProposalClosed(uint indexed id, uint winningOptionIdx);
    /** OWNER ‑‑ simply the deployer for simplicity */
    address public owner;
    modifier onlyOwner() {
        require(msg.sender == owner, "not owner");
        _;
    }
    constructor() {
        owner = msg.sender;
    }
    /**
* @notice create a proposal; `options` MUST be ["Yes", "No"] for
Binary.
*/
    function createProposal(
        string memory _title,
        string memory _description,
        ProposalType _pType,
        string[] memory _options
    ) external onlyOwner returns (uint id) {
        require(_options.length >= 2, "need >=2 options");
        if (_pType == ProposalType.Binary) {
            require(_options.length == 2, "binary needs 2 opts");
        }
        id = ++proposalCount;
        Proposal storage p = proposals[id];
        p.title = _title;
        p.description = _description;
        p.pType = _pType;
        p.options = _options;
        p.open = true;
        p.created = block.timestamp;
        emit ProposalCreated(id, _title, _pType);
    }
    /**
* @notice anonymous vote. Caller supplies:
* ‑ `nullifier` – hash(secret) that uniquely identifies the voter
* ‑ `optionIdx` – which option (0 = "Yes" in binary)
* ‑ `proof` – zk‑SNARK proof that (secret ∈ memberRoot)
without
* revealing secret or wallet.
* In this demo, `verifyProof` **always** returns true. Plug in a
real
* verifier (e.g. generated by SnarkJS/Groth16) for production.
*/
    function vote(
        uint proposalId,
        bytes32 nullifier,
        uint optionIdx,
        bytes calldata proof
    ) external {
        Proposal storage p = proposals[proposalId];
        require(p.open, "voting closed");
        require(optionIdx < p.options.length, "bad option");
        require(!p.nullifiers[nullifier], "already voted");
        require(verifyProof(proof, nullifier), "invalid proof");
        p.nullifiers[nullifier] = true;
        p.tally[optionIdx] += 1;
        emit VoteCast(proposalId, optionIdx, nullifier);
    }
    /** OWNER can end voting and emit the winner */
    function closeProposal(uint proposalId) external onlyOwner {
        Proposal storage p = proposals[proposalId];
        require(p.open, "already closed");
        p.open = false;
        uint winner;
        uint high = 0;
        for (uint i = 0; i < p.options.length; i++) {
            if (p.tally[i] > high) {
                high = p.tally[i];
                winner = i;
            }
        }
        emit ProposalClosed(proposalId, winner);
    }
    /** read helper */
    function tallies(
        uint proposalId
    ) external view returns (uint[] memory arr) {
        Proposal storage p = proposals[proposalId];
        arr = new uint[](p.options.length);
        for (uint i; i < arr.length; i++) arr[i] = p.tally[i];
    }
}
